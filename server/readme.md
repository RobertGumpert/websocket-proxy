# src/proxy/Server

Решение заключает в том, что для каждого клиента
храним открытое соедиение и пулл сообщений полученных от
других клиентов.

Для каждого клиента, отправку сообщений ему и получения их от него,
выполняем параллельно основному потоку (главной горутине main).
Получение сообщения от клиента и передачу его другим клиентам осуществляется
через канал, который хранит все полученные сообщения от всех клиентов
за Квант вемени. Чтение сообщения из канала и передачу его в пул других клиентов
осуществляется в отдельной горутине. Запись в канал осуществляется в горутине клиента.

Здесь мы храним объекты всех подключенных клиентов. Отключение клиентов выполняется
в горутинах клиентов, а вот удаление и создание экземпляра клиента выполняется здесь.
Переход с HTTP на TCP для нового клиента выполняется в основном потоке, а вот управление
передачей и получения сообщений выполняется в отдельных горутинах каждого нового клиента.
Таким образом основной поток только ожидает либо новых новых клиентов, либо занимается
другим делами.

### Пересылка сообщений подключенным клиентам
```go
...

go this.redirect()

...

func (this *Server) redirect() {
	for msg := range this.redirectChannel {
		for _, cl := range this.clients {
			...
			// Проверяем закрыто ли соединение с клиентов
			if cl.PossiblySendingMessage() {
				// Отправляем собщение в пул клиента
				cl.Send(
					msg,
				)
			}
            ...
		}
	}
}
```

# src/client/Client

Решение заключает в том, что для каждого клиента
храним открытое соедиение и пулл сообщений полученных от
других клиентов.

Отправка сообщений клиенту будет осуществляться каждый Квант времени,
ведя статистику попыток отправить каждое сообщение из пула.
Сообщение будут считаться невалидными если кол-во попыток отправить
его клиенту превысит установленный порог.
Невалидные сообщения удаляются из пула.

Получение сообщения от другого клиента происходит из объекта Proxy,
который читает его из канала, хранящего сообщения полученные от все клиентов.

Здесь мы регламентируем порядок получения сообщения от клиента
и отправки сообщения клиенту.
Каждое сообщения полученное от клиента,
пишем в канал содержащий сообщения полученные от всех клиентов.
Сообщения от других клиентов получаем из этого же канала,
но через промежудочное звено - объект Proxy, который непосредственно
читает очередное сообщение из канала и передает его в пул каждого клиента.

### Отправка сообщений клиенту
```go
...

go this.send()

...

func (this *Client) Send(msg model.Message) {
	...
	this.pool = append(this.pool, &message{
		msg: msg,
	})
	...
}

...

func (this *Client) send() {
	for {
		select {
        ...
		case <-timer.C:
			for index, msg := range this.pool {
				// Если счетчик сообщения достиг предельного
				// кол-ва попыток отправить его, удаляем.
				// С целью экономии места, отправим самый свежие сообщения
				// сообщения если клиент вдруг проснется
				if msg.countRepeat == this.maxCountRepeat {
					this.deleteFromPool(index)
				}
				err := this.connection.WriteMessage(
					msg.msg.Type,
					msg.msg.Content,
				)
				if err != nil {
					...
					msg.countRepeat++
				} else {
                    ...
					this.deleteFromPool(index)
				}
			}
		}
	}
}
```

### Получениe сообщения от клиента
```go
...

go this.read()

...

func (this *Client) read() {
	for {

		msgType, msgBytes, err := this.connection.ReadMessage()
        
        ...

		go func() {
			// Пишем полученное от клиента сообщение в канал 
 			// рассылки сообщений другим клиентам
			this.redirectChannel <- model.Message{
				Receiver: this.RemoteAddr,
				Type:     msgType,
				Content:  msgBytes,
			}
		}()
	}

    ...
}
```

# Тестирование

Тестирование провоилось на фейковых клиентах созданных с помощью пакета httptest

Запуск теста с демострацией работы: ./src/test go test -v -run TestProxyFlow